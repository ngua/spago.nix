# Created 2022-09-03 Sat 21:04
#+title: ~spago.nix~
#+author: Rory Tyler Hayford
#+export_file_name: ../README.org

üçù.‚ùÑ

* Table of Contents :toc:
- [[#introduction][Introduction]]
- [[#quick-start][Quick Start]]
- [[#motivation][Motivation]]
- [[#documentation][Documentation]]
- [[#caveats][Caveats]]
- [[#acknowledgments][Acknowledgments]]

* Introduction
~spago.nix~ is tool that aims to provide ergonomic Nix integration for Purescript projects built with [[https:github.com/purescript/spago][Spago]]. It aims to supersede tools such as [[https:github.com/justinwoo/spago2nix][~spago2nix~]] and provide the following features:

- *Zero* autogenerated Nix code for users (but see the [[#caveats][caveats]] below)
- A flakes-first workflow
- Support for easily generating flakes outputs (~devShells~, ~packages~, and ~checks~)

See the [[#motivation][Motivation]] below for more information on why ~spago.nix~ was created.

* Quick Start
1. Add ~github:ngua/spago-nix~ to your flake input
2. Add ~inputs.spago-nix.overlays.default~ to your ~overlays~ where you import ~nixpkgs~
3. Initialize a project with ~pkgs.spago-nix.spagoProject~. The only two required arguments to this function are ~src~ and ~name~ (see the [[#documentation][documentation]] for more)
4. *Optional*: If your Spago project depends on any third-party dependencies (i.e. /not/ in an upstream package set), add them to your flake inputs and include them in the ~extraSources~ argument to ~spagoProject~
5. ~spagoProject~ returns a ~flake~ attribute with some default ~packages~, ~apps~, and ~devShells~, along with functions for creating more outputs (see the [[#documentation][documentation]] for more details)

*Example*:

#+begin_src nix
{
  description = "Simple purescript.nix example";
  inputs = {
    nixpkgs.follows = "spago-nix/nixpkgs";
    spago-nix.url = "github:ngua/spago.nix";
    flake-utils.url = "github:numtide/flake-utils";

    # Additional Purescript dependencies can be pinned in your flake `inputs`
    # and then provided to `spagoProject` via `extraSources` (see below)
    lattice = {
      url = "github:Risto-Stevcev/purescript-lattice/v0.3.0";
      flake = false;
    };
    properties = {
      url = "github:Risto-Stevcev/purescript-properties/v0.2.0";
      flake = false;
    };
  };

  outputs =
    { self
    , nixpkgs
    , spago-nix
    , flake-utils
    , ...
    }@inputs:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = import nixpkgs {
          inherit system;
          # This is necessary to access the various functionality that `spago.nix`
          # provides. The entire interface is exposed via the `spago-nix` prefix
          # in the resulting package set
          overlays = [ spago-nix.overlays.default ];
        };
        # `spago-nix.spagoProject` is the key function for building your Spago
        # project with Nix. It provides various attributes, some of which are
        # demonstrated below (see `./docs/reference.org` for all of them)
        project = pkgs.spago-nix.spagoProject {
          name = "spago-nix-example";
          src = ./.;
          # These are third-party dependencies that don't exist in the upstream
          # package set. The pinned inputs *must* match the exact revision that
          # is described in your `packages.dhall`, otherwise your project likely
          # won't compile
          extraSources = { inherit (inputs) lattice properties; };
          # This is used to generate a `devShell`. See `./docs/reference.org` for
          # all of the available options
          shell = {
            tools = [ "psa" ];
          };
        };
      in
      {
        # `spagoProject` returns, among other things, a `flake` attribute with
        # some pre-built outputs for your convenience
        devShells = { inherit (project.flake.devShells) default; };
        # `flake.packages` contains the compiled `output` and `docs`. Since
        # Spago does has no mechanism for defining components in your config,
        # `spagoProject` also returns functions for creating the derivations
        # that cannot be generated for you automatically
        packages = project.flake.packages // {
          bundled-module = project.bundleModule { main = "Main"; };
          bundled-app = project.bundleApp { main = "Main"; };
          node-app = project.nodeApp { main = "Main"; };
        };
        # Similarly, `flake.apps` contains a `docs` app that serves the documentation
        # from a webserver on `localhost`
        apps = project.flake.apps // {
          # `spago-nix.utils` has some helpers for reusing existing `packages`
          # to create `apps`
          node-app = pkgs.spago-nix.utils.apps.fromNodeApp {
            app = self.packages.${system}.node-app;
          };
        };
      }
    );
}
#+end_src

* Motivation
The status quo for building Purescript projects with Nix is unfortunately quite lackluster. Neither Spago nor its chosen configuration language, Dhall, are particularly amenable to working in pure environments such as the Nix build sandbox.

The current default choice for Purescript users wanting to build with Nix is ~spago2nix~. Unfortunately, ~spago2nix~ requires generating and committing Nix code (its ~spago-packages.nix~). Seemingly obscure build errors can arise when users forget to run ~spago2nix generate~, which is not a rare occurrence in my experiences. ~spago2nix~ provides a very limited interface that is very far from that of ~spago~ -- if users wish to build project documentation, for example, they must write derivations by hand.

Worse, ~spago2nix~ cannot be run in a pure environment. Spago's package format does not include the hashes for listed dependencies, meaning that these must be calculated somehow before fetching the sources for each dependency. ~spago2nix~ does this by calling ~nix-prefetch-git~ for each dependency (as does ~spago.nix~, but in a different step that does not affect users). This could be worked around by using fixed-output derivations, but that provides an unpleasant interface.

Most of the time, a user's ~spago-packages.nix~ will primarily contain the same Purescript packages from upstream package sets. In this case, we can generate the Nix package sets containing hashes for each dependency and then store them in a central repository, emulating package sets like ~nodePackages~ in the ~nixpkgs~ repo. Doing this allows us to create a suitable package set for users in a pure environment and removes the need for committing any generated Nix code.

* Documentation
- [[file:./docs/reference.org][Reference]]

* Caveats
TODO

* Acknowledgments
TODO
